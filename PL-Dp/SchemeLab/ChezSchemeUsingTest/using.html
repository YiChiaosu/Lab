<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Using Chez Scheme</title>
<link href="csug.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g5"></a>
<a name="./use:h0"></a>

<h1>Chapter 2. Using Chez Scheme<a name="CHPTUSE"></a></h1>





<p>
<i>Chez&nbsp;Scheme</i> is often used interactively to support program development
and debugging, yet it may also be used to create stand-alone applications
with no interactive component.
This chapter describes the various ways in which <i>Chez&nbsp;Scheme</i> is
typically used and, more generally, how to get the most out of the
system.
The chapter is organized as follows.
Sections&nbsp;<a href="./use.html#g6">2.1</a> and&nbsp;<a href="./use.html#g7">2.2</a> describe how
one uses <i>Chez&nbsp;Scheme</i> interactively.
Section&nbsp;<a href="./use.html#g8">2.3</a> describes how to create and use
compiled files.
Section&nbsp;<a href="./use.html#g10">2.5</a> covers command-line options used when
invoking <i>Chez&nbsp;Scheme</i>.
Section&nbsp;<a href="./use.html#g11">2.6</a> covers support for writing and running
Scheme scripts, including compiled scripts.
Section&nbsp;<a href="./use.html#g12">2.7</a> describes how one can customize the
startup process, e.g., to alter or eliminate the command-line options,
to preload Scheme or foreign code, or to run <i>Chez&nbsp;Scheme</i> as a subordinate
program of another program.
Section&nbsp;<a href="./use.html#g13">2.8</a> describes how to build applications
using <i>Chez&nbsp;Scheme</i> with <i>Petite&nbsp;Chez&nbsp;Scheme</i> for run-time support.
Finally, Section&nbsp;<a href="./use.html#g9">2.4</a> describes how to structure
and compile an application to get the most efficient code possible out
of the compiler.

<p>

<h3><a name="g6"></a><a name="./use:h1"></a>Section 2.1. Interacting with Chez Scheme<a name="SECTUSEINTERACTION"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> can be used interactively simply by running the executable
image without arguments or by selecting the <i>Chez&nbsp;Scheme</i> icon from
the application startup menu.
Many experienced Scheme programmers prefer to use <i>Chez&nbsp;Scheme</i> via
GNU Emacs, which provides a sophisticated editor while allowing the
Scheme system to run in a subordinate window.
Less experienced users may prefer the
<a  href=http://www.scheme.com/swl.html>Scheme Widget Library</a>
(SWL), which provides an integrated development environment with a
much simpler editor.
While the discussion in this section is tailored specifically to
interacting with the base Scheme system outside of SWL or Emacs, most
of the discussion applies equally in all three environments.

<p>
When used interactively,
<i>Chez&nbsp;Scheme</i> prompts the user with a right angle bracket "<tt>&gt;</tt>"
at the beginning of each input line.
Any Scheme expression may be entered.
The system evaluates the expression and prints the result.
After printing the result, the system prompts again for more input.

<p>
Typically, a Scheme programmer creates a source file of Scheme forms
using a text editor
and loads the file into <i>Chez&nbsp;Scheme</i> to test them.
The conventional filename extension for <i>Chez&nbsp;Scheme</i> source files is
"<tt>.ss</tt>".
A source file may be loaded during an interactive session by typing
<a name="./use:s0"></a><tt>(load&nbsp;"<i>filename</i>")</tt>.
Files to be loaded may also be named on the command line when the
system is started.
Any form that may be
typed interactively may be placed in a file to be loaded.

<p>
You can exit the system by typing the end-of-file character
or by using the procedure
<a name="./use:s1"></a><tt>exit</tt>.
Typing the end-of-file character is equivalent to <tt>(exit)</tt>,
<tt>(exit&nbsp;(void))</tt>, or <tt>(exit&nbsp;0)</tt>, each of which is
considered a normal exit.
Any other argument to <tt>exit</tt> is considered an abnormal exit
and returns an error status to the invoking shell.

<p>
Interaction of the system with the user is performed by a Scheme
program called a <a name="./use:s2"></a><i>waiter</i>, running in a program
state called a <a name="./use:s3"></a><i>caf&eacute;</i>.
The waiter is a read-evaluate-print loop, or REPL: it prompts for
input, reads the input, evaluates the input, prints the result, and
loops back for more.

<p>
Running programs may be interrupted by typing the interrupt
character (typically Control-C).
In response, the
system enters a debug handler, which prompts for input with a
"<tt>debug&gt;</tt>" prompt.
Several commands may be issued to the debug handler, including
<dl compact>
<dt>"e"<dd> or end-of-file to exit from the handler and continue,
<dt>"r"<dd> to stop execution and reset to the current caf&eacute;,
<dt>"a"<dd> to abort <i>Chez&nbsp;Scheme</i>,
<dt>"n"<dd> to enter a new caf&eacute; (see below),
<dt>"i"<dd> to inspect the current continuation,
<dt>"s"<dd> to display statistics about the interrupted program, and
<dt>"?"<dd> to display a list of these options.
</dl>
While typing an input expression to the waiter, the interrupt character
simply resets to the current caf&eacute;.

<p>
When an error occurs, the system prints an error message and resets.
Typing (debug) after an error occurs places you into the
debug handler, where you can inspect the current continuation (control
stack) to help determine the cause of the problem.

<p>
It is possible to open up a chain of <i>Chez&nbsp;Scheme</i>
caf&eacute;s by invoking the <a name="./use:s4"></a><tt>new-cafe</tt> procedure
with no arguments.
Entering a new cafe is also one of the options when an interrupt
occurs (see below).
Each caf&eacute; has its own reset and exit handlers.
Exiting from one caf&eacute; in the chain returns you to the next one
back, and so on, until the entire chain closes and you leave the
system altogether.
Sometimes it is useful to
interrupt a long computation by typing the interrupt character,
enter a new caf&eacute; to execute something (perhaps to check a status
variable set by the computation), and exit the caf&eacute; back to the old
computation.

<p>
You can tell what level you are at by the number of angle brackets
in the prompt, one for level one, two for level two, and so on.
Three angle brackets in the prompt means you would have to exit from
three caf&eacute;s to leave <i>Chez&nbsp;Scheme</i>.
If you wish to abort
from <i>Chez&nbsp;Scheme</i> and you are several caf&eacute;s deep, the procedure
<a name="./use:s5"></a><tt>abort</tt> leaves the system directly.

<p>

<h3><a name="g7"></a><a name="./use:h2"></a>Section 2.2. Expression Editor<a name="SECTUSEEXPEDITOR"></a></h3>



<p>
When Chez Scheme is used interactively in a
shell window, the waiter's "prompt and read"
procedure employs an expression editor that permits entry and editing of
single- and multiple-line expressions, automatically indents expressions
as they are entered, and supports name-completion based on the identifiers
defined in the interactive environment.
The expression editor also maintains a history of expressions typed during
and across sessions and supports tcsh-like history movement and search
commands.
Other editing commands include simple cursor movement via
arrow keys, deletion of characters via backspace and delete, and
movement, deletion, and other commands using mostly
emacs key bindings.

<p>
The expression editor does not run if the TERM environment variable is
not set, if the standard input or output files have been redirected, or
if the <tt>--eedisable</tt> command-line option
(Section&nbsp;<a href="./use.html#g10">2.5</a>) has been used.
The history is saved across sessions, by default, in the file
".chezscheme_history" in the user's home directory.
The <tt>--eehistory</tt> command-line option
(Section&nbsp;<a href="./use.html#g10">2.5</a>) can be used to specify a different
location for the history file or to disable the saving and restoring of
the history file.

<p>
Keys for nearly all printing characters (letters, digits, and special
characters) are "self inserting" by default.
The open parenthesis, close parenthesis, open bracket, and close bracket
keys are self inserting as well, but also cause the editor to "flash"
to the matching delimiter, if any, and correct the close delimiter,
e.g., if a close paren matches up with an open bracket.

<p>
Key bindings for other keys and key sequences initially recognized by
the expression editor are given below, organized into groups by function.
Some keys or key sequences serve more than one purpose depending upon
context.
For example, tab is used both for identifier completion and for
indentation.
Such bindings are shown in each applicable functional group.

<p>
Multiple-key sequences are displayed with hyphens between the keys of
the sequences, but these hyphens should not be entered.
When two or more key sequences perform the same operation, the sequences
are shown separated by commas.

<p>
Detailed descriptions of the editing commands are given in
Chapter&nbsp;<a href="./expeditor.html#g109">13</a>, which also describes parameters that allow
control over the expression editor, mechanisms for adding or changing key
bindings, and mechanisms for creating new commands.



<p>


<p>
<p> Newlines, acceptance, exiting, and redisplay:
<p><TABLE><TR><TD nowrap align="left">
enter, <tt>^M</tt>        </TD><TD nowrap align="left"> accept balanced entry if used at end of entry;</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> else add a newline before the cursor and indent</TD></TR><TR><TD nowrap align="left">
<tt>^J</tt>               </TD><TD nowrap align="left"> accept entry unconditionally</TD></TR><TR><TD nowrap align="left">
<tt>^O</tt>               </TD><TD nowrap align="left"> insert newline after the cursor and indent</TD></TR><TR><TD nowrap align="left">
<tt>^D</tt>               </TD><TD nowrap align="left"> exit from the waiter if entry is empty;</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> else delete character under cursor</TD></TR><TR><TD nowrap align="left">
<tt>^Z</tt>               </TD><TD nowrap align="left"> suspend to shell if shell supports job control</TD></TR><TR><TD nowrap align="left">
<tt>^L</tt>               </TD><TD nowrap align="left"> redisplay entry</TD></TR><TR><TD nowrap align="left">
<tt>^L</tt>-<tt>^L</tt>      </TD><TD nowrap align="left"> clear screen and redisplay entry
</TD></TR></TABLE>
<p>

<p>
 Basic movement and deletion:
<p><TABLE><TR><TD nowrap align="left">
leftarrow, <tt>^B</tt>    </TD><TD nowrap align="left"> move cursor left</TD></TR><TR><TD nowrap align="left">
rightarrow, <tt>^F</tt>   </TD><TD nowrap align="left"> move cursor right</TD></TR><TR><TD nowrap align="left">
uparrow, <tt>^P</tt>      </TD><TD nowrap align="left"> move cursor up; from top of unmodified entry,</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> move to preceding history entry.</TD></TR><TR><TD nowrap align="left">
downarrow, <tt>^N</tt>    </TD><TD nowrap align="left"> move cursor down; from bottom of unmodified entry,</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> move to next history entry.</TD></TR><TR><TD nowrap align="left">
<tt>^D</tt>               </TD><TD nowrap align="left"> delete character under cursor if entry not empty;</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> else exit from the waiter.</TD></TR><TR><TD nowrap align="left">
delete, <tt>^H</tt>       </TD><TD nowrap align="left"> delete character before cursor
</TD></TR></TABLE>
<p>

<p>
 Line movement and deletion:
<p><TABLE><TR><TD nowrap align="left">
home, <tt>^A</tt>         </TD><TD nowrap align="left"> move cursor to beginning of line</TD></TR><TR><TD nowrap align="left">
end, <tt>^E</tt>          </TD><TD nowrap align="left"> move cursor to end of line</TD></TR><TR><TD nowrap align="left">
<tt>^K</tt>,
esc-<tt>^K</tt>           </TD><TD nowrap align="left"> delete to end of line or, if cursor is at the end</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> of a line, join with next line</TD></TR><TR><TD nowrap align="left">
<tt>^U</tt>               </TD><TD nowrap align="left"> delete contents of current line
</TD></TR></TABLE>
<p>

<p>
When used on the first line of a multiline entry of which only the first line
is displayed, i.e., immediately after history movement, <tt>^U</tt> deletes the
contents of the entire entry, like <tt>^G</tt> (described below).

<p>
 Expression movement and deletion:
<p><TABLE><TR><TD nowrap align="left">
esc-<tt>^F</tt>           </TD><TD nowrap align="left"> move cursor to next expression</TD></TR><TR><TD nowrap align="left">
esc-<tt>^B</tt>           </TD><TD nowrap align="left"> move cursor to preceding expression</TD></TR><TR><TD nowrap align="left">
esc-<tt>]</tt>         </TD><TD nowrap align="left"> move cursor to matching delimiter</TD></TR><TR><TD nowrap align="left">
<tt>^]</tt>               </TD><TD nowrap align="left"> flash cursor to matching delimiter</TD></TR><TR><TD nowrap align="left">
esc-<tt>^K</tt>           </TD><TD nowrap align="left"> delete next expression</TD></TR><TR><TD nowrap align="left">
esc-delete,
esc-<tt>^H</tt>           </TD><TD nowrap align="left"> delete preceding expression
</TD></TR></TABLE>
<p>

<p>
 Entry movement and deletion:
<p><TABLE><TR><TD nowrap align="left">
esc-<tt>&lt;</tt>         </TD><TD nowrap align="left"> move cursor to beginning of entry</TD></TR><TR><TD nowrap align="left">
esc-<tt>&gt;</tt>         </TD><TD nowrap align="left"> move cursor to end of entry</TD></TR><TR><TD nowrap align="left">
<tt>^G</tt>               </TD><TD nowrap align="left"> delete current entry contents</TD></TR><TR><TD nowrap align="left">
<tt>^C</tt>               </TD><TD nowrap align="left"> delete current entry contents; reset to end of history
</TD></TR></TABLE>
<p>

<p>
 Indentation:
<p><TABLE><TR><TD nowrap align="left">
tab                    </TD><TD nowrap align="left"> re-indent current line if identifier prefix not</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> just entered; else insert identifier completion</TD></TR><TR><TD nowrap align="left">
esc-tab                </TD><TD nowrap align="left"> re-indent current line unconditionally</TD></TR><TR><TD nowrap align="left">
esc-<tt>q</tt>,
 esc-<tt>Q</tt>,
 esc-<tt>^Q</tt>          </TD><TD nowrap align="left"> re-indent each line of entry
</TD></TR></TABLE>
<p>

<p>
 Identifier completion:
<p><TABLE><TR><TD nowrap align="left">
tab                    </TD><TD nowrap align="left"> insert identifier completion if just entered</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> identifier prefix; else re-indent current line</TD></TR><TR><TD nowrap align="left">
tab-tab                </TD><TD nowrap align="left"> show possible identifier completions at end of</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> identifier just typed, else re-indent</TD></TR><TR><TD nowrap align="left">
<tt>^R</tt>               </TD><TD nowrap align="left"> insert next identifier completion
</TD></TR></TABLE>
<p>

<p>
If at end of existing identifier, i.e., not one just typed, the first tab
re-indents, the second tab inserts identifier completion, and the third
shows possible completions.

<p>
 History movement:
<p><TABLE><TR><TD nowrap align="left">
uparrow, <tt>^P</tt>      </TD><TD nowrap align="left"> move to preceding entry if at top of unmodified</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> entry; else move up within entry</TD></TR><TR><TD nowrap align="left">
downarrow, <tt>^N</tt>    </TD><TD nowrap align="left"> move to next entry if at bottom of unmodified</TD></TR><TR><TD nowrap align="left">
                       </TD><TD nowrap align="left"> entry; else move down within entry</TD></TR><TR><TD nowrap align="left">
esc-uparrow,
 esc-<tt>^P</tt>          </TD><TD nowrap align="left"> move to preceding entry from unmodified entry</TD></TR><TR><TD nowrap align="left">
esc-downarrow,
 esc-<tt>^N</tt>          </TD><TD nowrap align="left"> move to next entry from unmodified entry</TD></TR><TR><TD nowrap align="left">
esc-p                  </TD><TD nowrap align="left"> search backward through history for given prefix</TD></TR><TR><TD nowrap align="left">
esc-n                  </TD><TD nowrap align="left"> search forward through history for given prefix</TD></TR><TR><TD nowrap align="left">
esc-P                  </TD><TD nowrap align="left"> search backward through history for given string</TD></TR><TR><TD nowrap align="left">
esc-N                  </TD><TD nowrap align="left"> search forward through history for given string
</TD></TR></TABLE>
<p>

<p>
To search, enter a prefix or string followed by one of the search key
sequences.
Follow with additional search key sequences to search further backward or
forward in the history.
For example, enter "(define" followed by one or more esc-p key sequences
to search backward for entries that are definitions, or "(define"
followed by one or more esc-P key sequences for entries that contain
definitions.

<p>
 Word and page movement:
<p><TABLE><TR><TD nowrap align="left">
esc-<tt>f</tt>,
  esc-<tt>F</tt>       </TD><TD nowrap align="left"> move cursor to end of next word</TD></TR><TR><TD nowrap align="left">
esc-<tt>b</tt>,
  esc-<tt>B</tt>       </TD><TD nowrap align="left"> move cursor to start of preceding word</TD></TR><TR><TD nowrap align="left">
<tt>^X</tt>-<tt>[</tt>    </TD><TD nowrap align="left"> move cursor up one screen page</TD></TR><TR><TD nowrap align="left">
<tt>^X</tt>-<tt>]</tt>    </TD><TD nowrap align="left"> move cursor down one screen page
</TD></TR></TABLE>
<p>

<p>
 Inserting saved text:
<p><TABLE><TR><TD nowrap align="left">
<tt>^Y</tt>               </TD><TD nowrap align="left"> insert most recently deleted text</TD></TR><TR><TD nowrap align="left">
<tt>^V</tt>               </TD><TD nowrap align="left"> insert contents of window selection/paste buffer
</TD></TR></TABLE>
<p>

<p>
 Mark operations:
<p><TABLE><TR><TD nowrap align="left">
<tt>^@</tt>,
  <tt>^</tt>space,
  <tt>^^</tt>             </TD><TD nowrap align="left"> set mark to current cursor position</TD></TR><TR><TD nowrap align="left">
<tt>^X</tt>-<tt>^X</tt>      </TD><TD nowrap align="left"> move cursor to mark, leave mark at old cursor position</TD></TR><TR><TD nowrap align="left">
<tt>^W</tt>               </TD><TD nowrap align="left"> delete between current cursor position and mark
</TD></TR></TABLE>
<p>

<p>
 Command repetition:
<p><TABLE><TR><TD nowrap align="left">
esc-<tt>^U</tt>           </TD><TD nowrap align="left"> repeat next command four times</TD></TR><TR><TD nowrap align="left">
esc-<tt>^U</tt>-<i>n</i>       </TD><TD nowrap align="left"> repeat next command <i>n</i> times
</TD></TR></TABLE>
<p>


<p>

<h3><a name="g8"></a><a name="./use:h3"></a>Section 2.3. Creating and Using Compiled Files<a name="SECTUSECOMPILEDFILES"></a></h3>



<p>
<i>Chez&nbsp;Scheme</i> compiles source forms as it sees them to machine
code before evaluating them.
In order to speed loading of a large file or group of files, the files
may be compiled with the output placed in separate object files
via <tt>compile-file</tt>.

<p>
<a name="./use:s6"></a>(compile-file "<tt><i>filename</i></tt>") compiles
the forms in the file <tt><i>filename</i></tt>.ss and places the
resulting object code in the file <tt><i>filename</i></tt>.so.
Loading a pre-compiled file is essentially no different from
loading the source file, except that loading is faster since
compilation is already done.

<p>
If a file to be loaded from source or compiled and loaded from object code
contains forms that are intended to affect the compilation of subsequent
forms, however, some adjustments are necessary to make sure that these
forms are evaluated at compile time.
One way to do this is to remove the forms that affect compilation
and place them into a separate file that is loaded prior to
compilation.
Another way is to use <a name="./use:s7"></a><tt>eval-when</tt>, which is discussed in detail
in&nbsp;<a href="./system.html#g91">11.3</a>.
It may also be that one file defines a set of syntactic abstractions
or modules that must be present during the compilation of another file.
In this case, the former file must be compiled first in the same
session as the latter file, or "visited" via <tt>visit</tt> before
the second file is compiled.
<tt>visit</tt> is also described in&nbsp;<a href="./system.html#g91">11.3</a>.

<p>
For example, assume that the file frob.ss contains the following forms,
with actual code in place of the dashes.

<p>

<p><tt>(case-sensitive&nbsp;#t)<br>

(optimize-level&nbsp;2)<br>

(load&nbsp;"frob-helpers.ss")
<br>
<br>
(define&nbsp;parse-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define-syntax&nbsp;make-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define-syntax&nbsp;frob-case<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;sort-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;process-frob<br>

&nbsp;&nbsp;---)</tt>
<p>Also, assume that <tt>make-frob</tt> and <tt>frob-case</tt> use the common
helper <tt>parse-frob</tt> to parse their input at expansion time and
that <tt>frob-helpers.ss</tt> defines some macro definitions that are
used in the definitions of <tt>sort-frob</tt> and <tt>process-frob</tt>.

<p>
The calls to <tt>case-sensitive</tt> and <tt>optimize-level</tt> affect
each of the subsequent forms when frob.ss is loaded from source, but since
they won't be evaluated when the file is compiled, they will not have the
desired affect when the file is compiled.
The file frob-helpers.ss is also loaded before the rest of frob.ss when
frob.ss is loaded from source, as desired, but not when frob.ss is compiled.
Furthermore, when frob.ss is loaded from source, the procedure
<tt>parse-frob</tt> is defined before it is needed for any uses
of <tt>make-frob</tt> and <tt>frob-case</tt> in the definitions of
<tt>sort-frob</tt> and <tt>process-frob</tt>, but it is not available
until run time when frob.ss is compiled.

<p>
All of these problems can be solved by wrapping the first several forms
in an <a name="./use:s8"></a><tt>eval-when</tt> as shown below.

<p>

<p><tt>(eval-when&nbsp;(compile&nbsp;load&nbsp;eval)<br>

&nbsp;&nbsp;(case-sensitive&nbsp;#t)<br>

&nbsp;&nbsp;(optimize-level&nbsp;2)<br>

&nbsp;&nbsp;(load&nbsp;"frob-helpers.ss")
<br>
<br>
&nbsp;&nbsp;(define&nbsp;parse-frob<br>

&nbsp;&nbsp;&nbsp;&nbsp;---))
<br>
<br>
(define-syntax&nbsp;make-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define-syntax&nbsp;frob-case<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;sort-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;process-frob<br>

&nbsp;&nbsp;---)</tt>
<p>The given <tt>eval-when</tt> form causes the forms in its body to be
evaluated when the file is compiled and also when the compiled file is
subsequently loaded.
It also causes them to be evaluated if the file is ever loaded from
source.
It is possible to leave out one or more of the <tt>compile</tt>, <tt>load</tt>,
and <tt>eval</tt> "situations" so that the forms are not evaluated when
they are not needed.
For example, you may not want to change case sensitivity or the optimization
level when the file is loaded, so you can use the following instead.

<p>

<p><tt>(eval-when&nbsp;(compile&nbsp;eval)<br>

&nbsp;&nbsp;(case-sensitive&nbsp;#t)<br>

&nbsp;&nbsp;(optimize-level&nbsp;2))
<br>
<br>
(eval-when&nbsp;(compile&nbsp;load&nbsp;eval)<br>

&nbsp;&nbsp;(load&nbsp;"frob-helpers.ss")
<br>
<br>
&nbsp;&nbsp;(define&nbsp;parse-frob<br>

&nbsp;&nbsp;&nbsp;&nbsp;---))
<br>
<br>
(define-syntax&nbsp;make-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define-syntax&nbsp;frob-case<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;sort-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;process-frob<br>

&nbsp;&nbsp;---)</tt>
<p>Macro definitions are implicitly wrapped in an <tt>eval-when</tt> with
situations <tt>compile</tt>, <tt>load</tt>, and <tt>eval</tt>, so there
is no need to wrap them explicitly unless you wish to restrict when they
are available, e.g., to avoid loading them when the compiled file is
loaded if they are not needed at run time.

<p>
Another possibility is to move the first several forms into a separate
file and load it before compiling frob.ss.  In this case, they will all be
evaluated only at compile time.

<p>
If the file frob-helpers.ss loaded by frob.ss is compiled, it may not
be necessary to do a full load of the file both at compile time and run time.
It may suffice to "visit" the file (load only compile-time information
like macro and module interfaces) at compile time using <a name="./use:s9"></a><tt>visit</tt>
instead of <tt>load</tt> and "revisit" the file (load only run-time
information like variable definitions) at run time using <a name="./use:s10"></a><tt>revisit</tt>.

<p>

<p><tt>(eval-when&nbsp;(compile&nbsp;eval)<br>

&nbsp;&nbsp;(case-sensitive&nbsp;#t)<br>

&nbsp;&nbsp;(optimize-level&nbsp;2))
<br>
<br>
(eval-when&nbsp;(eval)&nbsp;(load&nbsp;"frob-helpers.so"))<br>

(eval-when&nbsp;(compile)&nbsp;(visit&nbsp;"frob-helpers.so"))<br>

(eval-when&nbsp;(load)&nbsp;(revisit&nbsp;"frob-helpers.so"))
<br>
<br>
(eval-when&nbsp;(compile&nbsp;load&nbsp;eval)<br>

&nbsp;&nbsp;(define&nbsp;parse-frob<br>

&nbsp;&nbsp;&nbsp;&nbsp;---))
<br>
<br>
(define-syntax&nbsp;make-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define-syntax&nbsp;frob-case<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;sort-frob<br>

&nbsp;&nbsp;---)
<br>
<br>
(define&nbsp;process-frob<br>

&nbsp;&nbsp;---)</tt>
<p><a name="./use:s11"></a>When compiling a file or set of files, it is often more convenient to
use a shell command than to enter <i>Chez&nbsp;Scheme</i> interactively to perform
the compilation.
This is easily accomplished by "piping" in the command to compile
the file as shown below.

<p>

<p><tt>echo&nbsp;'(compile-file&nbsp;"filename")'&nbsp;|&nbsp;scheme&nbsp;-q</tt>
<p>The "-q" option suppresses the system's greeting messages for more
compact output, which is especially useful when compiling numerous
files.
(Under Windows, the single quotes around the <tt>compile-file</tt>
call should be omitted.)

<p>
When running in this "batch" mode, especially from within "make"
files, it is often desirable to force the error handler to exit
immediately to the shell with a nonzero exit status.
This may be accomplished by setting the
<a name="./use:s12"></a><tt>reset-handler</tt> to
<tt>abort</tt>.

<p>

<p><tt>echo&nbsp;'(reset-handler&nbsp;abort)&nbsp;(compile-file&nbsp;"filename")'&nbsp;|&nbsp;scheme&nbsp;-q</tt>
<p>One can also redefine the <a name="./use:s13"></a><tt>error-handler</tt>
(see page&nbsp;<a href="./system.html#defn:error-handler">244</a>) to achieve a similar affect
while exercising more control over the format of the error messages that
are produced.

<p>

<h3><a name="g9"></a><a name="./use:h4"></a>Section 2.4. Optimization<a name="SECTUSEOPTIMIZATION"></a></h3>



<p>
<a name="./use:s14"></a>To get the most out of the <i>Chez&nbsp;Scheme</i> compiler, it is necessary to
give it a little bit of help.
The most important assistance is to avoid the use of top-level bindings.
Top-level bindings are convenient and appropriate during program
development, since they simplify testing, redefinition, and tracing
(Section&nbsp;<a href="./debug.html#g15">3.1</a>) of individual procedures and
syntactic forms.
This convenience comes at a sizable price, however.

<p>
<a name="./use:s15"></a><a name="./use:s16"></a>The compiler can propagate copies (of one variable to another or of
a constant to a variable) and inline procedures bound to unexported,
unassigned variables within a single top-level expression.
For the procedures it does not inline, it can avoid constructing and
passing unneeded closures, bypass argument-count checks, branch to the
proper entry point in a case-lambda, and build rest arguments (more
efficiently) on the caller side, where the length of the rest list is
known at compile time.
It can also discard the definitions of unreferenced variables, so there's
no penalty for including a large library of routines, only a few of
which are actually used.
  
<p>
It cannot do any of this with top-level variable bindings, since the
top-level bindings can change at any time and new references to those
bindings can be introduced at any time.
This is true for primitives like <tt>car</tt>, <tt>cons</tt>, and
<tt>+</tt> as well as for user-defined procedures.

<p>
Fortunately, it is easy to restructure a program to avoid top-level
bindings.
It is best to do this incrementally as an application is being developed
by moving the more well-tested portions of the program out of the
top level and into a "local" scope.
For portable code, the best way to make bindings local rather than
top level is to wrap them in a "let nil" expression.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;a&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;b&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;c&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;d&nbsp;---))</tt>
<p>If one or more of the bindings must remain visible at top-level, they
should be created via a dummy definition before the <tt>let</tt> and
assigned the actual value within the <tt>let</tt>.

<p>

<p><tt>(define&nbsp;d&nbsp;#f)<br>

(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;a&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;b&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;c&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;local-d&nbsp;---)<br>

&nbsp;&nbsp;(set!&nbsp;d&nbsp;local-d))</tt>
<p>References to the value of <tt>d</tt> within the <tt>let</tt> should
be replaced with references to <tt>local-d</tt> so that the only
references to the top-level <tt>d</tt> are outside of this block of
code.

<p>
Assuming there are no assignments to <tt>a</tt>, <tt>b</tt>, <tt>c</tt>,
and <tt>d</tt> within the <tt>let</tt>, the compiler can now perform
a variety of optimizations that are disabled when top-level bindings
are used, like copy propagation and inlining.

<p>
<a name="./use:s17"></a><a name="./use:s18"></a><i>Chez&nbsp;Scheme</i> provides a module form that can be used to achieve the
same results without the dummy definition and assignment.

<p>

<p><tt>(module&nbsp;(d)<br>

&nbsp;&nbsp;(define&nbsp;a&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;b&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;c&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;local-d&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;d&nbsp;local-d))</tt>
<p><a name="./use:s19"></a>Modules may be named and explicitly imported so that the exported
bindings do not pollute the top-level namespace.

<p>

<p><tt>(module&nbsp;abcd&nbsp;(d)<br>

&nbsp;&nbsp;(define&nbsp;a&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;b&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;c&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;local-d&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;d&nbsp;local-d))
<br>
<br>
(let&nbsp;()&nbsp;(import&nbsp;abcd)&nbsp;(d&nbsp;---))</tt>
<p>Either way, a major source of inefficiency has been eliminated.
On the other hand, the fact that references to primitives like
<tt>car</tt>, <tt>cons</tt>, and <tt>+</tt> are still top level
may cost even more efficiency.
Addressing this is also straightforward.
All primitive bindings are available via the <tt>scheme</tt>
module.
When the base boot files are loaded,
these bindings are copied into the interactive top-level when
where they can be
redefined, but the original bindings in the <tt>scheme</tt>
module are immutable, i.e., cannot be redefined or assigned.
These immutable bindings can be made visible by importing from
the <a name="./use:s20"></a><tt>scheme</tt> module within the top-level <tt>let</tt>
or <tt>module</tt> form.

<p>

<p><tt>(module&nbsp;abcd&nbsp;(d)<br>

&nbsp;&nbsp;(import&nbsp;scheme)<br>

&nbsp;&nbsp;(define&nbsp;a&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;b&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;c&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;local-d&nbsp;---)<br>

&nbsp;&nbsp;(define&nbsp;d&nbsp;local-d))
<br>
<br>
(let&nbsp;()&nbsp;(import&nbsp;abcd)&nbsp;(d&nbsp;---))</tt>
<p>Now, all references to primitives are known by the compiler to have
their original values, which allows them to be open-coded (coded inline
in machine code) or even folded to constant values at compile time.

<p>
The best possible code is obtained when the all of the code for the
entire application is contained in a single top-level <tt>let</tt> or
<tt>module</tt> form.
It is often more convenient, however, to place portions of the application
code in different files, especially for large applications.
The solution is to use <a name="./use:s21"></a><tt>include</tt> rather than <tt>load</tt> to
bring the code into the system.
While <tt>load</tt> reads and executes code at run time, <tt>include</tt>
reads the code at compile time and splices it into to the current
lexical context as if it had been present in the source code.
To be effective, of course, the <tt>include</tt> forms must be inside
of a top-level <tt>let</tt> or <tt>module</tt> form.

<p>

<p><tt>(module&nbsp;(d)<br>

&nbsp;&nbsp;(import&nbsp;scheme)<br>

&nbsp;&nbsp;(include&nbsp;"file1.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file2.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file3.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file4.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file5.ss"))</tt>
<p>Incidentally, <tt>(import-only&nbsp;scheme)</tt> may be used in place of
<tt>(import&nbsp;scheme)</tt> to prevent access to the interactive
top-level environment.

<p>

<p><tt>(module&nbsp;(d)<br>

&nbsp;&nbsp;(import-only&nbsp;scheme)<br>

&nbsp;&nbsp;(include&nbsp;"file1.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file2.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file3.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file4.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file5.ss"))</tt>
<p>This causes the expander to report attempts to reference or assign
unbound identifiers, i.e., any identifier not bound in the scheme
module, bound in some other module imported within one of the files,
or bound locally within one of the files.
The generated code is the same regardless of the form of import used.

<p>
With an application structured in this manner, we have done most of
what we can do to help the compiler, but there are still a few things
we can do.

<p>
<a name="./use:s22"></a><a name="./use:s23"></a>First, we can allow the compiler to generate "unsafe" code, i.e.,
allow the compiler to generate code in which the usual run-time type
checks have been disabled.
We do this by using the compiler's "optimize level 3."
The following allows the compiler to generate unsafe code when the
application is compiled but forces it to generate safe code when it
is loaded from source.

<p>

<p><tt>(eval-when&nbsp;(compile)&nbsp;(optimize-level&nbsp;3))
<br>
<br>
(module&nbsp;(d)<br>

&nbsp;&nbsp;(import&nbsp;scheme)<br>

&nbsp;&nbsp;(include&nbsp;"file1.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file2.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file3.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file4.ss")<br>

&nbsp;&nbsp;(include&nbsp;"file5.ss"))</tt>
<p>The default optimization level is 0.
Another useful optimization level is 2, but its use is no longer
recommended.
Optimize level 2 is safe, like optimize level 0, but allows the compiler
to assume that primitives like <tt>car</tt> always have their original
value.
While this is important, as described above, it is usually clearer
and more convenient to use <tt>(import&nbsp;scheme)</tt> rather than set the
optimization level.
If you wish to get a quick boost without wrapping the program in
a top-level <tt>let</tt> or module form and inserting 
<tt>(import&nbsp;scheme)</tt> where appropriate, however, setting the
optimization level to 2 might still be useful.
Optimize level 1 is presently identical to optimize level 0.

<p>
It may also be useful to experiment with some of the other compiler
control parameters and also with the storage manager's run-time
operation.
The compiler-control parameters are described in
Section&nbsp;<a href="./system.html#g93">11.5</a>, and the storage manager control
parameters are described in Section&nbsp;<a href="./smgmt.html#g106">12.1</a>.

<p>
<a name="./use:s24"></a>Finally, it is often useful to "profile" your code to determine that
parts of the code that are executed most frequently.
While this will not help the system optimize your code, it can help
you identify "hot spots" where you need to concentrate your own
hand-optimization efforts.
In these hot spots, consider using more efficient operators, like
fixnum or flonum operators in place of generic arithmetic operators,
and using explicit loops rather than nested combinations of
linear list-processing operators like <tt>append</tt>, <tt>reverse</tt>,
and <tt>map</tt>.
These operators can make code more readable when used judiciously,
but they can slow down time-critical code.

<p>
Section&nbsp;<a href="./system.html#g94">11.6</a> describes how to use the compiler's support
for automatic profiling.
Be sure that profiling is not enabled when you compile your production
code, since the code introduced into the generated code to perform the
profiling significant to run-time overhead.

<p>

<h3><a name="g10"></a><a name="./use:h5"></a>Section 2.5. Command-Line Options<a name="SECTUSECOMMANDLINE"></a></h3>



<p>
<a name="./use:s25"></a><a name="./use:s26"></a><a name="./use:s27"></a><a name="./use:s28"></a><a name="./use:s29"></a><a name="./use:s30"></a><a name="./use:s31"></a><a name="./use:s32"></a><a name="./use:s33"></a><a name="./use:s34"></a><a name="./use:s35"></a><a name="./use:s36"></a><a name="./use:s37"></a><a name="./use:s38"></a><a name="./use:s39"></a><a name="./use:s40"></a><a name="./use:s41"></a><a name="./use:s42"></a><i>Chez&nbsp;Scheme</i> recognizes the following command-line options.

<p>
<TABLE><TR><TD nowrap align="left">
<tt>-b&nbsp;<i>path</i></tt>, <tt>--boot&nbsp;<i>path</i></tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;load boot file</TD></TR><TR><TD nowrap align="left">
<tt>-c</tt>, <tt>--compact</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;toggle compaction flag</TD></TR><TR><TD nowrap align="left">
<tt>--eedisable</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;disable expression editor</TD></TR><TR><TD nowrap align="left">
<tt>--eehistory&nbsp;off|<i>path</i></tt>
   </TD><TD nowrap align="left"> expression-editor history file</TD></TR><TR><TD nowrap align="left">
<tt>-h&nbsp;<i>path</i></tt>, <tt>--heap&nbsp;<i>path</i></tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;load heap file</TD></TR><TR><TD nowrap align="left">
<tt>-q</tt>, <tt>--quiet</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;suppress greeting and prompt</TD></TR><TR><TD nowrap align="left">
<tt>-s[<i>n</i>]&nbsp;<i>path</i></tt>, <tt>--saveheap[<i>n</i>]&nbsp;<i>path</i></tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;save heap file</TD></TR><TR><TD nowrap align="left">
<tt>--script&nbsp;<i>path</i></tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;run as shell script</TD></TR><TR><TD nowrap align="left">
<tt>--verbose</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;trace boot/heap search process</TD></TR><TR><TD nowrap align="left">
<tt>--version</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;print version and exit</TD></TR><TR><TD nowrap align="left">
<tt>--help</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;print help and exit</TD></TR><TR><TD nowrap align="left">
<tt>--</tt>
    </TD><TD nowrap align="left"> &nbsp;&nbsp;pass through remaining args</TD></TR><TR><TD nowrap align="left">
</TD></TR></TABLE>

<p>
Any remaining command-line arguments are treated as the names of files
to be loaded before <i>Chez&nbsp;Scheme</i> begins interacting with the user.

<p>
The "-c", "-h", "-s", and
"-verbose" options are described
in detail below.
The "-script" option is described in Section&nbsp;<a href="./use.html#g11">2.6</a>.
The "-eedisable" and "-eehistory" options are described in
Section&nbsp;<a href="./use.html#g7">2.2</a>.
The others should be self-explanatory.

<p>
<a name="./use:s43"></a><a name="./use:s44"></a>When <i>Chez&nbsp;Scheme</i> is run, it looks for one or more boot files
and/or one or more heap files to load.
Boot files contain the compiled Scheme code that implements most of
the Scheme system, including the interpreter, compiler, and most
libraries.
Heap files contain prebuilt heap images, i.e., saved heap images
into which the boot code has already been loaded.
Heap and boot files may be specified explicitly on the command
line via "-b" and "-h" options or implicitly.
In the simplest case, no "-b" and "-h" options
are given and the necessary heap or boot files are loaded
automatically based on the name of the executable.

<p>
For example, if the executable name is "frob", the
system looks for "frob.heap" in a set of standard
directories, then for "frob.boot".
It also looks for and loads any subordinate heaps or boot files required
by "frob.heap" or "frob.boot".

<p>
Subordinate heap and boot files are also loaded automatically for the
first boot file and any heap files explicitly specified via the command line.
When boot and heap files are specified via the command line, all heap
files must come before all boot files, and each file must be listed
before those that depend upon it.

<p>
The "-verbose" option may be used to trace the heap and boot file
searching process and must appear before any boot or heap arguments
for which search tracing is desired.

<p>
Ordinarily, the search for heap and boot files is limited to a set of
default installation directories, but this may be overridden by setting
the environment variable <a name="./use:s45"></a><tt>SCHEMEHEAPDIRS</tt>.
<tt>SCHEMEHEAPDIRS</tt> should be a colon-separated list of directories, listed in
the order in which they should be searched.
Within each directory, the two-character escape sequence "<tt>%v</tt>"
is replaced by the current version, and the two-character escape sequence
"<tt>%m</tt>" is replaced by the machine type.
A percent followed by any other character is replaced by the second
character; in particular, "<tt>%%</tt>" is replaced by "<tt>%</tt>", and
"<tt>%:</tt>" is replaced by "<tt>:</tt>".
If <tt>SCHEMEHEAPDIRS</tt> ends in a non-escaped colon, the default directories are
searched after those in <tt>SCHEMEHEAPDIRS</tt>; otherwise, only those listed in
<tt>SCHEMEHEAPDIRS</tt> are searched.
Under Windows, semi-colons are used in place of colons.

<p>
Boot files consist of ordinary compiled code and are created by
concatenating a boot header onto the compiled code for one or more
source files.
See Section&nbsp;<a href="./use.html#g13">2.8</a> for instructions on how to create
boot files.

<p>
A heap file is a snapshot image of a Scheme heap, where all Scheme
code and data is stored.
They have both advantages and disadvantages relative to boot files.
A heap file generally loads faster than the corresponding boot file,
since all of the forms have already been evaluated.
On systems supporting memory-mapped files with copy-on-write
semantics, such as most Unix systems, most of the the contents of a
heap may be shared by multiple Scheme processes, whereas each Scheme
process has its own copy of code and data loaded from a boot file.
On the other hand, heap files are not relocatable, and some operating
systems do not guarantee that the heap can be loaded where it needs
to be loaded.
If it cannot be loaded into the proper range of addresses, an error
is signaled at system startup time and the system exits.
This occurs particularly often under both Windows and MacOS X.
Even with operating systems that are more consistent in the range of
addresses provided to the Scheme process, heap files built on one
machine often cannot be used on another machine, so they cannot
generally be distributed in lieu of boot files and must be rebuilt
on the target machine.

<p>
For these reasons, we recommend that boot files be used for distributed
applications unless startup time and/or sharing among multiple Scheme
processes is critical.

<p>
Heap files are created via the "-s" option.
If the "-s" option is present and <i>Chez&nbsp;Scheme</i> exits normally
as described in Section&nbsp;<a href="./use.html#g6">2.1</a>,
it will save the heap in the specified file.
The heap contains the entire state of the
system, so that any procedures or other objects created during a
session are retained.

<p>

<p><tt>%&nbsp;scheme&nbsp;-s&nbsp;heap<br>

&gt;&nbsp;(define&nbsp;square&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x)))<br>

&gt;&nbsp;(exit)
<br>
<br>
%&nbsp;scheme&nbsp;-h&nbsp;heap<br>

&gt;&nbsp;(square&nbsp;3)<br>

9</tt>
<p>The heap level is determined by the heap-level argument <tt><i>n</i></tt>.
A level zero heap contains the entire heap, a level one heap
contains only those portions that differ from the corresponding level
zero heap, and so on.
If no level follows the "-s" option, the level defaults to the
level of the highest level heap loaded or zero if no heaps have been loaded.

<p>
A level one heap may be created in a session in which a level zero heap has
been loaded, and the level one heap can be loaded with an additional
"-h" option:

<p>

<p><tt>%&nbsp;scheme&nbsp;-h&nbsp;heap&nbsp;-s&nbsp;heap1<br>

&gt;&nbsp;(define&nbsp;abs&nbsp;(lambda&nbsp;(x)&nbsp;(sqrt&nbsp;(square&nbsp;x))))<br>

&gt;&nbsp;(exit)
<br>
<br>
%&nbsp;scheme&nbsp;-h&nbsp;heap&nbsp;-h&nbsp;heap1<br>

&gt;&nbsp;(square&nbsp;3)<br>

9<br>

&gt;&nbsp;(abs&nbsp;-3)<br>

3</tt>
<p>If the special level "+" follows the "-s" option, the
level is one level higher than the highest loaded heap or zero if no heaps
have been loaded.
Thus, the following three lines create level zero, one, one, and two heaps.

<p>

<p><tt>%&nbsp;echo&nbsp;|&nbsp;&#123;InstallSchemeName&#125;&nbsp;-b&nbsp;petite.boot&nbsp;-s&nbsp;heap.0<br>

%&nbsp;echo&nbsp;|&nbsp;&#123;InstallSchemeName&#125;&nbsp;-h&nbsp;heap.0&nbsp;-s+&nbsp;heap.1<br>

%&nbsp;echo&nbsp;|&nbsp;&#123;InstallSchemeName&#125;&nbsp;-h&nbsp;heap.1&nbsp;-s&nbsp;heap.1<br>

%&nbsp;echo&nbsp;|&nbsp;&#123;InstallSchemeName&#125;&nbsp;-h&nbsp;heap.1&nbsp;-s+&nbsp;heap.2</tt>
<p>After any boot files are loaded, the heap is compacted and the remaining
heap storage is made static and is no longer subject to collection.
The heap is also compacted by default before a heap file is saved.
This can consume significant time and additional memory for very large
heaps.
The "-c" option can be used to disable this latter compaction.
Multiple "-c" options toggle heap compaction; it is thus
possible to use a shell script that disables compaction by default
while still allowing compaction if desired.
The "-c" option has no effect if the "-s" option has
not been specified.

<p>

<h3><a name="g11"></a><a name="./use:h6"></a>Section 2.6. Scheme Shell Scripts<a name="SECTUSESCRIPTING"></a></h3>



<p>
<a name="./use:s46"></a><a name="./use:s47"></a><a name="./use:s48"></a>When the "-script" command-line option is present, the named file is
treated as a Scheme shell script, and the command-line is made
available via the parameter
<tt>command-line</tt>.
This is primarily useful on Unix-based systems, where the script file
itself may be made executable.
To support executable shell scripts, the system ignores the first
line of a loaded script if it begins with <tt>#!</tt> followed by
a space or forward slash.
For example, assuming that the <i>Chez&nbsp;Scheme</i> executable has been
installed as /usr/bin/scheme, the following script prints its command-line
arguments.

<p>

<p><tt>#!&nbsp;/usr/bin/scheme&nbsp;--script<br>

(for-each<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(display&nbsp;x)&nbsp;(newline))<br>

&nbsp;&nbsp;(cdr&nbsp;(command-line)))</tt>
<p>The following script implementation of the traditional Unix <tt>echo</tt>
command.

<p>

<p><tt>#!&nbsp;/usr/bin/scheme&nbsp;--script<br>

(let&nbsp;([args&nbsp;(cdr&nbsp;(command-line))])<br>

&nbsp;&nbsp;(unless&nbsp;(null?&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;([(newline?&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(equal?&nbsp;(car&nbsp;args)&nbsp;"-n")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;#f&nbsp;(cdr&nbsp;args))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values&nbsp;#t&nbsp;args))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([args&nbsp;args&nbsp;(cdr&nbsp;args)]&nbsp;[sep&nbsp;""&nbsp;"&nbsp;"])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;args))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"~a~a"&nbsp;sep&nbsp;(car&nbsp;args)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;newline?&nbsp;(newline)))))</tt>
<p>Scripts may be compiled using <a name="./use:s49"></a><tt>compile-script</tt>, which is like
<tt>compile-file</tt> but differs in two ways:
(1) it copies the leading <tt>#!</tt> line from the source-file script
into the object file, and (2) it disables the default compression of
the resulting file, which would otherwise prevent it from being
recognized as a script file.

<p>

<h3><a name="g12"></a><a name="./use:h7"></a>Section 2.7. Customization<a name="SECTUSECUSTOMIZATION"></a></h3>



<p>
<a name="./use:s50"></a><a name="./use:s51"></a><a name="./use:s52"></a><a name="./use:s53"></a><i>Chez&nbsp;Scheme</i> and <i>Petite&nbsp;Chez&nbsp;Scheme</i> are built from several
subsystems, a "kernel" encapsulated in a shared
library (dynamic link library) that contains operating-system
interface and low-level storage management code,
an executable that parses command-line arguments and calls
into the kernel to initialize and run the system, a base
boot file (petite.boot) that contains the bulk of the run-time library code,
and an additional boot file (scheme.boot), for <i>Chez&nbsp;Scheme</i> only,
that contains the compiler.

<p>
While the <tt>kernel</tt> and base boot file are essential to the
operation of all programs, the executable may be replaced or
even eliminated, and the compiler boot file need be loaded only
if the compiler is actually used.
In fact, the compiler is usually never loaded for distributed
applications, since doing so would require each user to have a
license to run <i>Chez&nbsp;Scheme</i>.

<p>
The kernel exports a set of entry points that are used to initialize
the Scheme system, load boot or heap files, run an interactive Scheme
session, run script files, and deinitialize the system.
In the threaded versions of the system, the kernel also exports
entry points for activating, deactivating, and destroying threads.
These entry points may be used to create your own executable image
that has different (or no) command-line options or to run Scheme
as a subordinate program within another program, i.e., for use as
an extension language.

<p>
These entry points are described in Section&nbsp;<a href="./foreign.html#g28">4.6</a>,
along with other entry points for accessing and modifying Scheme
data structures and calling Scheme procedures.

<p>
<a name="./use:s54"></a>The tarball (tar.gz) distributions of <i>Chez&nbsp;Scheme</i> and
<i>Petite&nbsp;Chez&nbsp;Scheme</i> include within the distribution directory a
subdirectory called "custom."
This file custom.c in this subdirectory contains the 
"main" routine for the distributed executable image; look at
this file to gain an understanding of how the system startup
entry points are used.
The custom subdirectory also contains configuration code and
make files that can be used to rebuild the executable and
install the resulting system.

<p>

<h3><a name="g13"></a><a name="./use:h8"></a>Section 2.8. Building and Distributing Applications<a name="SECTUSEAPPLICATIONS"></a></h3>



<p>
<a name="./use:s55"></a><a name="./use:s56"></a>While <i>Chez&nbsp;Scheme</i> cannot be redistributed without fee, code compiled using
<i>Chez&nbsp;Scheme</i> is freely redistributable.
Compiled object files do not, however, contain the run-time library code
that is invariably required to run an application, including the code for
primitive procedures, code required to interact with the operating system,
and the storage manager.
Fortunately, this library code is also freely redistributable in the form of
<a name="./use:s57"></a><i>Petite&nbsp;Chez&nbsp;Scheme</i>, which
may be used and redistributed without license fee or
royalty for any purpose, including for resale as part of a commercial
product.
For details, see the <i>Petite Chez Scheme Software License
Agreement</i>, which is available in the distribution directory for
<i>Petite&nbsp;Chez&nbsp;Scheme</i> at <tt>http://www.scheme.com</tt>.

<p>
Although useful as a stand-alone Scheme system,
<i>Petite&nbsp;Chez&nbsp;Scheme</i> was conceived as a run-time system for compiled
<i>Chez&nbsp;Scheme</i> applications.
The remainder of 
this section describes how to create and distribute such applications.
using <i>Petite&nbsp;Chez&nbsp;Scheme</i>.
It begins with a discussion of the characteristics of
<i>Petite&nbsp;Chez&nbsp;Scheme</i> and how it compares with <i>Chez&nbsp;Scheme</i>,
then describes how to prepare application source code,
how to build and run applications, and how to distribute them.

<p>
<p><b>Petite Chez Scheme Characteristics.</b>&nbsp;&nbsp;Although interpreter-based, <i>Petite&nbsp;Chez&nbsp;Scheme</i> evaluates Scheme source
code faster than might be expected.
Some of the reasons for this are listed below.

<p>
<ul>
<li>The run-time system is fully compiled, so library implementations
of primitives ranging from <tt>+</tt> and <tt>car</tt> to <tt>sort</tt>
and <tt>printf</tt> are just as efficient as in <i>Chez&nbsp;Scheme</i>, although
they cannot be open-coded as in code compiled by <i>Chez&nbsp;Scheme</i> at high
levels of optimization.

<p>
<li>The interpreter is itself a compiled Scheme application.
Because it is written in Scheme, it directly benefits from various
characteristics of Scheme that would have to be dealt with explicitly
and with additional overhead in most other languages, including
proper treatment of tail calls, first-class procedures, automatic
storage management, and continuations.

<p>
<li>The interpreter employs a preprocessor that performs various
optimizations and converts the code into a form that can be interpreted
efficiently.
In fact, the preprocessor shares its front end with the compiler, and
this front end performs a variety of source-level optimizations.
</ul>
<p>

<p>
Nevertheless, compiled code is still far more efficient for most
applications.
The difference between the speed of interpreted and compiled code
varies significantly from one application to another, but can amount to
a factor of ten or more.

<p>
Two additional limitations result from the fact that
<i>Petite&nbsp;Chez&nbsp;Scheme</i> does not include the compiler.
First, the interpreter invokes the compiler to process
<tt>foreign-procedure</tt> and <tt>foreign-callable</tt>
forms.
These forms cannot be processed by the interpreter alone, so
they cannot appear in source code to be processed by <i>Petite&nbsp;Chez&nbsp;Scheme</i>.
Compiled versions of <tt>foreign-procedure</tt> and <tt>foreign-callable</tt>
forms may, however, be included
in compiled code loaded into <i>Petite&nbsp;Chez&nbsp;Scheme</i>.
Second, since inspector information is attached to code objects
generated only by the compiler, source information and variable names
are not available for interpreted procedures or continuations into
interpreted procedures.
This makes the inspector less effective for debugging interpreted code
than it is for debugging compiled code.

<p>
Except as noted above, <i>Petite&nbsp;Chez&nbsp;Scheme</i> does not restrict what
programs can do, and like <i>Chez&nbsp;Scheme</i>, it places essentially no
limits on the size of programs or the memory images they create.


<p>
<p><b>Preparing Application Code.</b>&nbsp;&nbsp;While it is possible to distribute applications in source-code form,
i.e., as a set of Scheme source files to be loaded into <i>Petite&nbsp;Chez&nbsp;Scheme</i>
by the end user, distributing compiled code has two major
advantages over distributing source code.
First, compiled code is usually much more efficient, as discussed in
the preceding section, and second, compiled code is in binary form and
thus provides more protection for proprietary application code.
For these reasons, we suggest that applications be compiled.

<p>
Application source code generally consists of a set of Scheme source
files possibly augmented by foreign code developed specifically for the
application and packaged in shared libraries (also known as shared
objects or, on Windows, dynamic link libraries).
The following assumes that any shared library source code has been
converted into object form; how to do this varies by platform.
(Some hints are given in Section&nbsp;<a href="./foreign.html#g25">4.3</a>.)
The result is a set of one or more shared libraries that are loaded
explicitly by the Scheme source code during program initialization.

<p>
Once the shared libraries have been created, the next step is to
compile the Scheme source files into a set of Scheme object files.
Doing so typically involves simply invoking <a name="./use:s58"></a><tt>compile-file</tt>
on each source (".ss") file to produce the corresponding object
(".so") file.
This may be done within a build script or "make" file via a
command line such as the following:

<p>

<p><tt>echo&nbsp;'(compile-file&nbsp;"filename")'&nbsp;|&nbsp;scheme</tt>
<p>which produces the object file <tt>filename.so</tt> from the source
file <tt>filename.ss</tt>.

<p>
If the application code has been developed interactively or is usually
loaded directly from source,
it may be necessary to make some adjustments to a file to be
compiled if the file contains expressions or definitions that
affect the compilation of subsequent forms in the file, as
described in Section&nbsp;<a href="./use.html#g8">2.3</a>.
You may also wish to disable generation of inspector information
both to reduce the size of the compiled application code and to
prevent others from having access to the expanded source code that
is retained as part of the inspector information.
To do so, set the parameter <tt>generate-inspector-information</tt> to
false either prior to calling <tt>compile-file</tt> or at the top
of each application source file, wrapped in an
<tt>eval-when</tt> with situation <tt>compile</tt> as shown in
Section&nbsp;<a href="./use.html#g8">2.3</a>.
The downside of disabling inspector information is that the information
will not be present if you need to debug your application, so it is
usually desirable to disable inspector information only for production
builds of your application.

<p>
Although it is possible to intersperse initialization expressions and
definitions at the top level of a Scheme source file, we suggest
that initialization expressions be encapsulated in one or more
initialization procedures that are explicitly invoked when the
application is created or run.
Initialization procedures to be invoked when the application is
run may be invoked by the Scheme startup procedure, which is
described below.

<p>
The Scheme startup procedure determines what the system does when
it is started.
The default startup procedure loads the files listed on the command
line (via <tt>load</tt>) and starts up a new caf&eacute;, like this.

<p>

<p><tt>(lambda&nbsp;fns&nbsp;(for-each&nbsp;load&nbsp;fns)&nbsp;(new-cafe))</tt>
<p>The startup procedure may be changed via the parameter
<a name="./use:s59"></a><tt>scheme-start</tt>.
The following example demonstrates the installation of a variant of the
default startup procedure that prints the name of each file before
loading it.

<p>

<p><tt>(scheme-start<br>

&nbsp;&nbsp;(lambda&nbsp;fns<br>

&nbsp;&nbsp;&nbsp;&nbsp;(for-each<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(fn)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"loading&nbsp;~a&nbsp;..."&nbsp;fn)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(load&nbsp;fn)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(printf&nbsp;"~%"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fns)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(new-cafe)))</tt>
<p>Scripts (see Section&nbsp;<a href="./use.html#g11">2.6</a>) use a different startup
procedure that is the value of the <a name="./use:s60"></a><tt>scheme-script</tt> parameter.
The default value of this parameter is a procedure that sets the
<tt>command-line</tt> and <tt>command-line-arguments</tt> parameters,
then loads the script.
<tt>command-line</tt> holds the script name and arguments, while
<tt>command-line-arguments</tt> holds just the arguments.

<p>

<p><tt>(lambda&nbsp;(fn&nbsp;.&nbsp;fns)<br>

&nbsp;&nbsp;(command-line&nbsp;(cons&nbsp;fn&nbsp;fns))<br>

&nbsp;&nbsp;(command-line-arguments&nbsp;fns)<br>

&nbsp;&nbsp;(load&nbsp;fn))</tt>
<p>A typical application startup procedure would first invoke the 
application's initialization procedure(s) and then start the
application itself:

<p>

<p><tt>(scheme-start<br>

&nbsp;&nbsp;(lambda&nbsp;fns<br>

&nbsp;&nbsp;&nbsp;&nbsp;(initialize-application)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(start-application&nbsp;fns)))</tt>
<p>Any shared libraries that must be present during the running of an
application must be loaded during initialization.
In addition, all foreign procedure expressions must be executed
after the shared libraries are loaded so that the addresses
of foreign routines are available to be recorded with the resulting foreign
procedures.
The following demonstrates one way in which initialization might be
accomplished for an application that links to a foreign procedure
<tt>show_state</tt> in the Windows shared library <tt>state.dll</tt>:

<p>

<p><tt>(define&nbsp;show-state)
<br>
<br>
(define&nbsp;app-init<br>

&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;(load-shared-object&nbsp;"state.dll")<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;show-state<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foreign-procedure&nbsp;"show_state"&nbsp;(integer-32)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer-32))))<br>

&nbsp;<br>

(scheme-start<br>

&nbsp;&nbsp;(lambda&nbsp;fns<br>

&nbsp;&nbsp;&nbsp;&nbsp;(app-init)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(app-run&nbsp;fns)))</tt>
<p><p><b>Building and Running the Application.</b>&nbsp;&nbsp;Building and running an application is straightforward once all shared
libraries have been built and Scheme source files have been compiled
to object code.

<p>
Although not strictly necessary, we suggest that you concatenate your
Scheme object files, if you have more than one, into a single object file.
This may be done on Unix systems simply via the "<tt>cat</tt>"
program or on Windows via <tt>copy</tt>.
Placing all of the object code into a single file
simplifies both building and distribution of applications.

<p>
With the Scheme object code contained within a single composite object file,
it is possible to run the application simply by loading the composite
object file into <i>Petite&nbsp;Chez&nbsp;Scheme</i>, e.g.:

<p>

<p><tt>petite&nbsp;app.so</tt>
<p>where <tt>app.so</tt> is the name of the composite object file,
and invoking the startup procedure to restart the system:

<p>

<p><tt>&gt;&nbsp;((scheme-start))</tt>
<p>It is usually preferable, however, to convert the composite object file
into a <a name="./use:s61"></a><i>boot file</i>.
Boot files are loaded during the process of building the initial heap.
Because of this, boot files have the following advantages over ordinary
object files.

<p>
<ul>
<li>Any redefinition of the Scheme startup procedure, i.e,. change
to the <tt>scheme-start</tt> parameter, takes affect before
the startup procedure is invoked, so there is no need to invoke the
new version explicitly as shown above.

<p>
<li>Any code and data structures contained in the boot file or created
while it is loaded is compacted along with the base run-time library
code and made static.
Static code and data are never collected by the storage manager, so
garbage collection overhead is reduced.

<p>
<li>The system looks for boot files automatically in a set of standard
directories based on the name of the executable image, so you can
install a copy of the <i>Petite&nbsp;Chez&nbsp;Scheme</i> executable image under your
application's name and spare your users from supplying any command-line
arguments or running a separate script to load the application code.
</ul>
<p>

<p>
A boot file is simply an object file, possibly a composite object
file created as described above, prefixed by a boot header.
The boot header identifies a base boot file upon which the application
directly depends, or possibly two or more alternatives upon which the
application can be run.
In most cases, "petite.boot" will be identified as the base boot
file, but in a layered application it may be another boot file of your
creation that in turn depends upon "petite.boot."
The base boot file, and its base boot file, if any, are loaded
automatically when your application boot file is loaded.

<p>
Boot headers are created with <a name="./use:s62"></a><tt>make-boot-header</tt>.
This procedure accepts two or more arguments.
The first is the name of a file into which the header
should be placed, and the remainder name one or more boot files
on top of which the application can be run.
For example, the call

<p>

<p><tt>(make-boot-header&nbsp;"app.hdr"&nbsp;"petite.boot")</tt>
<p>creates a header file that identifies a dependency upon "petite.boot,"
while the call

<p>

<p><tt>(make-boot-header&nbsp;"app.hdr"&nbsp;"scheme.boot"&nbsp;"petite.boot")</tt>
<p>creates a header file that identifies a dependency upon either
"scheme.boot" or "petite.boot."
In the former case, the system will automatically load petite.boot
when the application boot file is loaded, and in the latter it will
load scheme.boot if it can find it, otherwise petite.boot.
This would allow your application to run on top of the full
<i>Chez&nbsp;Scheme</i> if present, otherwise <i>Petite&nbsp;Chez&nbsp;Scheme</i>.

<p>
While <i>Petite&nbsp;Chez&nbsp;Scheme</i> is freely redistributable,
<i>Chez&nbsp;Scheme</i> may be used only under direct license
from Cadence Research Systems and may not be redistributed.
In most cases, this means that you should construct your application
so that it does not depend upon features of <i>Chez&nbsp;Scheme</i> and you
should specify only <tt>"petite.boot"</tt> in the call to
<tt>make-boot-header</tt>.
If your application calls <tt>eval</tt>, however, and you wish to
allow users who have licensed <i>Chez&nbsp;Scheme</i> to be able to take
advantage of the faster execution speed of compiled code, then specifying
both <tt>"scheme.boot"</tt> and <tt>"petite.boot"</tt>
is appropriate.

<p>
The resulting header can be concatenated onto the front of the 
object file to form the application header, again using <tt>cat</tt> under
Unix and <tt>copy</tt> under Windows.

<p>
<p><b>Distributing the Application.</b>&nbsp;&nbsp;Distributing an application involves creating a distribution package
that includes, at a minimum, the following items:

<p>
<ul>
<li>the <i>Petite&nbsp;Chez&nbsp;Scheme</i> distribution,
<li>the application boot file,
<li>any application-specific shared libraries,
<li>an application installation script.
</ul>
<p>

<p>
The application installation script should install <i>Petite&nbsp;Chez&nbsp;Scheme</i>
if not already installed on the target system.
It should install the application boot file in the same directory as
the <i>Petite&nbsp;Chez&nbsp;Scheme</i> boot file "petite.boot" is installed,
and it should should install the application shared libraries, if any,
either in the same location or in a standard location for shared libraries
on the target system.
It should also create a link to or copy of the <i>Petite&nbsp;Chez&nbsp;Scheme</i>
executable under the name of your application, i.e., the name given
to your application boot file.
Where appropriate, it should also install desktop and start-menu
shortcuts to run the executable.
A sample installation script for Unix platforms is given below.
For Windows, we suggest the use of an installation building program,
such as the open-source NullSoft Scriptable Install System (NSIS).

<p>
<p><b>Sample Unix Installation Script.</b>&nbsp;&nbsp;The script below demonstrates how to perform a straightforward
installation of a Scheme application on a Unix-based platform.
The script makes the following assumptions, any of which may be changed
by altering the script's application configuration parameters:

<p>
<ul>
<li>the name of the application to install is <tt>app</tt>,

<p>
<li>the machine type upon which the installation will take place
is <tt>i3le</tt> (Intel Linux),

<p>
<li>a single shared library, <tt>libapp.so</tt>, is included
in the distribution, and

<p>
<li>a single application boot file, <tt>app.boot</tt>, is included
in the distribution.
</ul>
<p>

<p>
The script also sets the default location for executables to
<tt>/usr/bin</tt> and shared libraries to <tt>/usr/lib</tt>.
These settings would typically be open to change by the end user;
a friendlier script would query the user to verify that these settings
are appropriate.

<p>
The script first installs <i>Petite&nbsp;Chez&nbsp;Scheme</i>, then installs the boot
file and shared libraries, then sets up the executable.

<p>

<p><tt>#&nbsp;installation&nbsp;directories<br>

prefix=/usr<br>

bin=$&#123;prefix&#125;/bin<br>

lib=$&#123;prefix&#125;/lib
<br>
<br>
#&nbsp;Petite&nbsp;Chez&nbsp;Scheme&nbsp;version&nbsp;information<br>

machine=i3le<br>

release=7.0
<br>
<br>
#&nbsp;application&nbsp;configuration<br>

app=app<br>

libs=lib$&#123;app&#125;.so<br>

boot=$&#123;app&#125;.boot
<br>
<br>
#&nbsp;install&nbsp;Petite&nbsp;Chez&nbsp;Scheme<br>

tar&nbsp;-xzf&nbsp;csv$&#123;release&#125;-$&#123;machine&#125;.tar.gz<br>

(cd&nbsp;csv$&#123;release&#125;/custom;&nbsp;./configure&nbsp;--installprefix=$&#123;prefix&#125;)<br>

(cd&nbsp;csv$&#123;release&#125;/custom;&nbsp;make&nbsp;install)
<br>
<br>
#&nbsp;install&nbsp;the&nbsp;boot&nbsp;file<br>

cp&nbsp;$&#123;boot&#125;&nbsp;$&#123;lib&#125;/csv$&#123;release&#125;/$&#123;machine&#125;<br>

chmod&nbsp;444&nbsp;
<br>
<br>
#&nbsp;install&nbsp;the&nbsp;shared&nbsp;libraries<br>

cp&nbsp;$&#123;libs&#125;&nbsp;$&#123;lib&#125;<br>

chmod&nbsp;444&nbsp;$&#123;libs&#125;
<br>
<br>
#&nbsp;create&nbsp;a&nbsp;link&nbsp;for&nbsp;the&nbsp;executable<br>

ln&nbsp;-s&nbsp;$&#123;bin&#125;/petite&nbsp;$&#123;bin&#125;/$&#123;app&#125;</tt>
<p>



<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it><a class=plain href="index.html">Chez Scheme Version 7 User's Guide</a></it><br>
Copyright &copy; 2005 R. Kent Dybvig<br>
Revised July 2007 for Chez Scheme Version 7.4<br>
Cadence Research Systems / <a class=plain href="http://www.scheme.com">www.scheme.com</a><br>
Cover illustration &copy; 1998 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN: 0-9667139-1-5<br>
<a class=plain href="http://stores.lulu.com/chezscheme">to order this book</a> /
<a class=plain href="canned/about.html">about this book</a></td>
</tr></table>
</body>
</html>
